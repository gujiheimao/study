# java 语法

java代码的执行，是由上到下的，从左到右的，由内到外，这是java代码执行的顺序。

出于对内容的考虑，先从领域比较小的部分开始学习

## 0.main方法

任何的程序都需要有一个入口，C需要，C#也需要，而java自然也是有的，在以下代码中，我们就定义了一个main方法
它是就是java程序的入口。

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("Hello World！");
    }
}
```

java中不像c和c++那种能函数式编程的语言，java中所有的东西都必须写在类的代码块中。
而在上面的代码中，对类的定义就是`public class Test` 这里定义了一个java类，名字叫Test，它的后面跟的`{}`是它的代码块

然后再类的代码块中，我们才正式的定义了一个个main方法，注意，不同于c能修改返回值，这里的main函数格式是固定的
`public static void main(String[] args)` 除了args你能修改之外，就不要指望修改其他。而这个main方法后面跟的自然就是main方法的代码块了。

然后我们在代码块中还看见了一行代码`System.out.println();`。它的作用就是java打印输出数据到控制台的代码，里面的`"Hello World！"`就是要打印输出的数据。

如果你想运行它，首先需要创建一个文件，**Test.java** ，这里需要注意，这个**Test**和之前的代码中的`public class Test`需要是一样的，
否则在后续的编译中会报错。

> ps：windows默认是不显示文件后缀的，需要到`资源管理器`->`查看`->勾选上`文件扩展名`

创建好文件之后，接下来将我们刚刚的代码写到文件当中去吧。这里推荐先用复制粘贴的方式写入文件当中，写完后`ctrl`+`S`保存文件 。

- windows 1：则`ctrl`+`R`，输入`cmd`+回车，cd到你的文件位置
    - 切换盘符用 `*:`，
    - cd 指令是`cd '文件夹'`
- windows 2:如果在'资源管理器'中，则直接在地址栏中输入cmd，就可以直接打开cmd
- linux：直接cd到java文件位置

在完成上面一步的时候，我们就已经到了java源文件的位置了。下面输入两个指令：
首先是输入`javac Text.java`然后回车执行。这个指令是将java源代码编译成java的字节码文件。也就是`Test.class`文件。
再然后是`java Text`然后回车执行。注意，这里的Text后面不用跟'.class'。在执行完这个指令之后，cmd也就会在控制台打印
`Hello World!`

## 1. 变量

再开发中，经常需要存储一些数据，比如姓名，年龄，身高，体重等等，这些数据都是以特定的形式存在的。
他们都有自己的类型，比如姓名是字符串类型，年龄是整数类型，身高是浮点类型，体重是浮点类型。
我们可以用一个东西，来存储他们，这个东西我们就称之为 **变量** 。

如它的名字一样，变量，变量，就是可以改变的量。就像是一个人的体重，他上个月可以是100斤，到了这个月可以是110斤。
会随着特定的条件进行量的修改。

### 定义

在java中，如果我们需要用一个变量来存储数据，那么我们需要先定义这个变量，然后才能使用这个变量。
对变量的定义格式如下:`数据类型 变量名 = 初始化值;`

具体到代码就是:

```java
public class Variable {
    public static void main(String[] args) {
        //定义一个 int 类型的变量，名字叫做 age，初始化值为 18
        int age = 18;
        //打印变量 age 的值
        System.out.println(age);
    }
}
```

我们详细讲讲上面的代码中我们干了些什么？

任何java中的变量，首先，都需要对它进行声明。这里我们就声明了一个变量，名字叫`age`。但是因为java是强类型语言，强类型语言不仅仅需要
声明变量名称，还需要对变量的类型进行声明。因此，我们在声明变量的时候，还需要声明变量的类型。在这里，我们声明的变量类型是`int`。

变量和变量类型之间需要用空格隔开,否则编译器不能识别，哪些是变量，哪些是变量类型。

再然后，我们在声明一个变量后对变量执行的一个赋值(赋值：赋予变量值)操作,就是给变量一个值。在这里，我们给变量`age`赋予了一个值`18`。
赋值符号就是`=`

之后，就是java语句结尾所需要的`;`，它使用来区分java语句结束位置的符号，如果你忘记在语句结束后加上它，那么编译器就会报错。

另外变量命名也不是随意命名的，需要遵循一点的规则，这个规则则是java标识符规则，规则如下：

1. 标识符只能由数字，字母，下划线，美元符号组成
2. 标识符不能以数字开头
3. 标识符不能是java中的关键字
4. 标识符区分大小写，只要有一个字符大小写不一样，那就是不一样的标识符
5. 标识符的长度没有限制，但是不建议太长，一般不超过15个字符

> ps：java是强类型语言，所有变量的类型一旦定义，就不能改变。不过有其他语言，比如js，就是弱类型语言，它是可以改变变量的类型的。

但是到了这里，你会发现变量我们只是声明了一个age变量，并没有体现它变量的特性。
因此我们接下来我们就要给变量修改值了！在声明变量之后，我们可以对变量进行重新赋值，代码如下。
这些代码编译运行后，会在控制台输出一行18和一行19

```java
public class Variable {
    public static void main(String[] args) {
        int age = 18;
        //打印变量 age 的值
        System.out.println(age);
        //这里已经声明过一次变量了，所以不要再次声明。重新赋值就可以了
        age = 19;
        //再次打印变量 age 的值
        System.out.println(age);
    }
}
```

之后我们可以多次赋值，多次打印，但是都不能对变量进行重新声明，因为变量只能声明一次。

### 常量

既然有变量，自然也就有常量。常量，就是不变的量。在java中，常量的定义格式如下：`final 数据类型 常量名 = 值;`。
只比变量定义多了一个 `final` 关键字。`final` 关键字的作用是，用来修饰常量，修饰了常量之后，这个常量就不能被修改了。
常量创建的时候，必须要给他一个值，否则编译器会报错。常量的命名规则和变量的命名规则一样，只不过在命名的时候，我们一般会用大写字母来命名。
具体的代码如下：

```java
public class Variable {
    public static void main(String[] args) {
        final int age = 18;
        //打印变量 age 的值
        System.out.println(age);
        //如果将下行代码的注释取消，你就会发现ide，或编译器都会标记错误，因为age被final定义为不可变的变量，也就是常量
        //age = 19;
    }
}
```

#### 术语

- 变量名：变量的名字，用来标识变量的唯一性,需要符合java标识符规范
- 赋值：就是给变量一个值，或修改一个变量的值
- (变量)初始化：变量初始化，就是指，在变量创建的时候，给他赋值

### 变量的作用域

变量的作用域规定了变量的作用范围，只有变量所在的作用域内，变量才会生效。不同的声明地点，变量的作用域也会不同

根据以上特点，可以将java变量划分为两种类型，一种是成员变量，一种是实例变量

#### 成员变量

成员变量又分为静态变量和实例变量，这两个变量都是定义在方法体和语句块之外的变量，也就是说，他们的作用域是整个类。

而他们二者的区别在于，静态变量是使用`static`关键字修饰的变量，而实例变量则是没有使用`static`关键字修饰的变量。

|  类型  |  修饰符   | 作用域 |         生命周期          |
|:----:|:------:|:---:|:---------------------:|
| 静态变量 | static | 整个类 |  随着类的加载而加载，随着类的消失而消失  |
| 实例变量 |   无    | 整个类 | 随着对象的创建而创建，随着对象的消失而消失 |

静态变量在全局中具有唯一性，也就是说，无论创建多少个对象，静态变量只有一份，并且修改了静态变量的值，之后再次调用静态变量的时候，值也会更新。

实例变量则不同，每个对象都有一份实例变量，修改了实例变量的值，不会影响其他对象的实例变量的值，也不会影响其他对象的静态变量的值。

在同一个类中，不能同时定义同名的静态变量和实例变量，因为他们会冲突。

##### 静态变量

静态变量的定义格式为：`static 数据类型 变量名 = 值;`。静态变量的访问格式为：`类名.静态变量名`。静态变量的访问格式为：`类名.静态变量名`。

```java
public class Variable {
    //定义一个静态变量
    static int age = 18;
    final static String name = "gu ji hei mao";
}

class Test {
    public static void main(String[] args) {
        //打印静态变量 age 的值
        System.out.println(Variable.age);
        //修改静态变量 age 的值
        Variable.age = 19;
        //再次打印静态变量 age 的值
        System.out.println(Variable.age);
        System.out.println("name = " + Variable.name);
    }
}
```

这里举例了一个Vairable类，和一个Test类。在Variable类中，我们定义了一个静态变量age，和一个静态常量name。
然后在Test类的main方法在，我们通过`类名.静态变量名`的方式，访问了Variable类中的静态变量age，和静态常量name。

#### 局部变量

局部变量又分为形参和方法内部定义的变量。他们的作用域都是在方法体内部，也就是说，他们只在方法体内部有效：

- 方法参数变量（形参）：在整个方法的代码块内有效。
- 方法局部变量（方法内定义）： 从这个变量定义开始，到定义的代码块执行结束这一段时间内有效。
- 代码块局部变量（代码块内定义）：从定义这个变量开始到代码块结束这一段时间内有效。

```java
public class Test {
    public static void main(String[] args) {
        //这里的a就是方法参数变量，也就是形参
        example(10);
        //这里无法访问方法参数变量中的a
        example(20);
    }

    public static void example(int a) {
        //这里的a就是方法参数变量，也就是形参
        int b = 10;
        //这里的b就是方法局部变量
        if (b > a) {
            int c = 20;
            //这里的c就是代码块局部变量
        }
        //这里的c就无法访问了
    }
}
```

在上面的代码中，我们定义了一个example方法，这个方法中有一个参数a，和两个局部变量b和c。
然后再main方法执行的时候，调用了examplle的方法，传入了一个参数10，和20。这个时候，example方法中的a就是10，b就是10，c就是20。

然后再example方法中，我们定义了一个if语句，这个if语句中又定义了一个局部变量c。这个时候，c的作用域就是从if语句开始，到if语句结束。
在if语句之外，就无法访问到c了。

# 基本数据类型

在java中，有八种基本的数据类型，是所有的数据都最小的单元，也就是说，所有的数据都是由这八种基本数据类型构成的。

基本数据类型中，有四种整型，两种浮点型，一种字符型，一种布尔型。

| 类型      | 占用字节(位数) | 取值范围               | 默认值      | 介绍           | 定义方式                |
|---------|----------|--------------------|----------|--------------|---------------------|
| byte    | 1(8)     | -(2^7) ~ (2^7)-1   | 0        | 用于表示字节数据     | `byte a = 10;`      |
| short   | 2(16)    | -(2^15) ~ (2^15)-1 | 0        | 用于表示短整型数据    | `short a = 10;`     |
| int     | 4(32)    | -(2^31) ~ (2^31)-1 | 0        | 用于表示整型数据     | `int a = 10;`       |
| long    | 8(64)    | -(2^63) ~ (2^63)-1 | 0        | 用于表示长整型数据    | `long a = 10;`      |
| float   | 4(32)    | -3.4E38 ~ 3.4E38   | 0.0      | 用于表示单精度浮点型数据 | `float a = 10.0f;`  |
| double  | 8(64)    | -1.7E308 ~ 1.7E308 | 0.0      | 用于表示双精度浮点型数据 | `double a = 10.0;`  |
| char    | 2(16)    | 0 ~ 65535          | '\u0000' | 用于表示字符型数据    | `char a = 'a';`     |
| boolean | 1(8)     | true/false         | false    | 用于表示布尔型数据    | `boolean a = true;` |

在这个表格中，我们可以看到，每种数据类型都有自己的取值范围，和默认值。其中，byte、short、int、long、float、double都是数字类型，char，boolean是布尔类型。

整型的定义是指整数，也就是没有小数点的数字。整型又分为四种，分别是byte、short、int、long。他们的区别在于，他们的占用字节不同，所能表示的数字范围不同。

## byte

byte是一个字节。byte的取值范围是-128 ~ 127。byte的默认值是0。
在java中可以直接在赋值的时候，在后面填数字，将数字赋值给byte。

在java中的定义方式也很简单，就是`byte b = 数字;` 这样就可以定义一个byte类型的变量了。
在这里的取值范围是-128 ~ 127。

一般在IO流中，会比较常接触到byte，因为IO流中的数据都是以字节为单位的。

## short

short占用的字节数比byte多，是两个字节。short的取值范围是-32768 ~ 32767。short的默认值是0。
在java中可以直接在赋值的时候，在后面填数字，将数字赋值给short。

在java中的定义方式同byte，就是`short s = 数字;` 这样就可以定义一个short类型的变量了。
在这里的取值范围是-32768 ~ 32767。不太常用

## int

int占用的字节数比short多，是四个字节。int的取值范围是-2147483648 ~ 2147483647。int的默认值是0。

在java中的定义方式同byte，就是`int i = 数字;` 这样就可以定义一个int类型的变量了。
在这里的取值范围是-2147483648 ~ 2147483647。java中所有的数字默认都是int类型的。 在Java中非常常用

## long

long占用8个字节long的取值范围大概是19位数字。long的默认值是0。基本上足够使用了。
在java中的定义方式同byte，就是`long l = 数字L;` 后面需要加上l或者L，以此表示这个数字是long类型的数字。
这里建议使用大写的L，因为小写的l和数字1长得太像了，容易混淆。

## float

float占用4个字节。float的取值范围是-3.4E38 ~ 3.4E38。float的默认值是0.0f。
他在赋值浮点型数字的时候需要再浮点型数字后面加上f或者F，以此表示这个数字是float类型的数字。
定义方式是`float f = 数字f;` 或者`float f = 数字F;`。

float有32位bit，其中划分计算方式如下：

| 位数    | 名称  | 计算公式                       |
|-------|-----|----------------------------|
| 1     | 符号位 | 0表示正数，1表示负数                |
| 1-9   | 指数位 | 将数字取出视为整数，127代表1次方，128代表平方 |
| 10-32 | 尾数位 | 在前面补上一个1                   |

首先是第一个位，这个的是`符号位`，0表示正数，1表示负数。这个代表：±

然后是后面的`指数位`，占8个bit，这个是用来表示这个数字的大小的，计算方式就是 x-127=指数。
至于0，则直接用0_00000000_00000000000000000000000表示。(\*^▽^\*)

然后是最后的`尾数位`，占23个bit，这里实际上是24位。只不过最前面的一位是固定的，就是1，所以实际上只有23位。
这个是用来表示这个数字的精度的。假设指数固定为1，那么如果尾数为0，那么这个数字就是1.0。
如果尾数为100_0000_0000_0000_0000_0000，也就是隐藏位数1的1/2。计算得出数字为1.5。
如果尾数为010_0000_0000_0000_0000_0000，也就是隐藏位数1的1/4。计算得出数字为1.25。
同理可以计算出尾数为111_0000_0000_0000_0000_0000=1+ 1/2 + 1/4 + 1/8 = 1.875。

他们的综合计算公式为：`(-1)^符号位 * 2^(指数位-127) * (1+尾数位)`

## double

double占用8个字节。double的取值范围是-1.7E308 ~ 1.7E308。double的默认值是0.0。
他在赋值浮点型数字的时候不需要再浮点型数字后面加上f或者F，因为java默认所有的浮点型数字都是double类型的。
定义方式是`double d = 数字;`。默认的浮点型数字都是double类型的。
虽然可以不用像float那样加上f或者F，但是也可以加上d或者D，以此表示这个数字是double类型的数字。

这里和float的区别就是，float是32位，double是64位。所以double的精度更高一些。

其中符号位占1位，指数位占11位，尾数位占52位。

其他的计算方式和float一样。

## char

char占用2个字节。char的取值范围是0 ~ 65535。char的默认值是'\u0000'。
char在大小上和short一样，但是他的取值范围是0 ~ 65535，而short的取值范围是-32768 ~ 32767。

而char的创建方式是`char c = '字符';`，这里的字符必须是单引号，而且只能是单个字符。
同样的还有其他的方式替代`'字符''`这个方式，

1. 直接使用`char c = 65;`，这里的65就是字符A的ASCII码，所以这里的c就是字符A。
2. 使用转义字符，`char c = '\u0041';`，这里的u0041就是字符A的Unicode码，所以这里的c就是字符A。
3. 使用转义字符，`char c = '\101';`，这里的101就是字符A的ASCII码，所以这里的c就是字符A。
4. 使用转义字符，`char c = '\x41';`，这里的x41就是字符A的16进制码，所以这里的c就是字符A。
5. 使用转义字符，`char c = '\t';`，这里的\t就是制表符，所以这里的c就是制表符。

其中转义字符的列表如下：

| 转义字符 | 作用  | Unicode码 | ASCII码 | 16进制码 | 
|------|-----|----------|--------|-------|
| \b   | 退格  | u0008    | 8      | 08    |
| \t   | 制表符 | u0009    | 9      | 09    |
| \n   | 换行  | u000A    | 10     | 0A    |
| \f   | 换页  | u000C    | 12     | 0C    |
| \r   | 回车  | u000D    | 13     | 0D    |
| \"   | 双引号 | u0022    | 34     | 22    |
| \'   | 单引号 | u0027    | 39     | 27    |
| \\   | 反斜杠 | u005C    | 92     | 5C    |

> ps: String的底层就是一个char数组，所以String也可以使用转义字符。

## boolean

boolean占用1个字节。boolean的取值范围是true或者false。boolean的默认值是false。
虽然boolean在大小上和byte一样，但是他的取值范围是true或者false
boolean的创建方式是`boolean b = true;`或者`boolean b = false;`。

可以用数值类型来做比较，获得boolean类型的值。
比如`boolean b = 1 > 2;`，这里的b就是false。
又或者是`boolean b = 1 == 1;`，这里的b就是true，与`boolean b = 10 != 10;`是一样的。


## 数据转换

关于数据转换，这里分为几个类别
第一个是整型之间的转换，第二个是浮点型之间的转换，第三个是整型和浮点型之间的转换，第四个是字符型和整型之间的转换。

### 整型之间的转换

整型之间的转换，主要是指byte、short、int、long之间的转换。

#### 符号间的计算

当byte和short进行计算的时候，计算的结果是int类型的。
但是当byte 或者 short 和 int 进行计算的时候，计算的结果是int类型的。
不过当int和long进行计算的时候，计算的结果就是long类型的。

低位和高位计算，结果自动转为高位类型。

#### 赋值转换

如果将数字赋值给byte或者short类型的变量，并且这个数字的二进制位数超过了byte或者short的取值范围，那么就会发生数据截断。
那么会发生数据截断，也就是说，如果数字的二进制位数超过了byte或者short的二进制位数，那么就会发生数据截断。
比如说，byte的二进制位数是8位，那么byte的取值范围就是-128 ~ 127。
如果将数字129赋值给byte类型的变量，那么这个数字的二进制位数是8位，超过了byte的二进制位数，所以就会发生数据截断。
得到的结果就是-127。

具体原因是，byte占有8个bit，129=0b10000001,byte最前面一个bit代表符号位这里就是负数，又因为byte的负数取的是正数的补码，
所以这里的补码就是0b01111111=127，所以这里的结果就是-127。

#### 低位转高位

因为地位的取值范围小于高位，所以低位转高位不会发生数据截断。

并且由于编程语言的处理方式，符号位会被自动转移到高位的符号位上，所以不会发生符号位的错误。
可以直接赋值，不会发生数据截断。例如

```java
byte b=1;
        short s=b;
```

#### 高位转低位

由于高位的精度，取值范围是大于低位的，所以高位转低位会发生数据截断。

例如int类型的65537，他的二进制为0b00000000 00000001 00000000 00000001，转换为short类型的时候，会发生数据截断。
会从低位开始截断，截断的位数是short的二进制位数，也就是16位，所以截断后的结果就是0b00000000 00000001，也就是1。

同时这个过程也会发生符号位的错误，如果符号位是1，所以这个时候就会发生符号位的错误，所以这个时候就会发生符号位的错误。
同样的以上面的举例二进制为0b10000000 00000001 00000000 00000001，那么它转为short类型的时候，截断后的结果就是-32767。

同时高位转地位的时候需要附带一个强制转换，因为高位转低位会发生数据截断，所以需要强制转换。

```java
int i=65537;
        short s=(short)i;
```

### 浮点型之间的转换

浮点型之间的转换，主要是指float和double之间的转换。
float转double不会发生数据截断，可以直接赋值使用。
两个float类型的变量相加，结果是float类型的。

但是如果是double转float，就会发生数据截断，需要强制转换。

```java
double d=1.1;
        float f=(float)d;
```

### 整型和浮点型之间的转换

byte，short，int，long，float，double之间的转换，主要是指整型和浮点型之间的转换。

#### 整型转浮点型

如果是整数类型转float类型，不会发生数据截断，可以直接赋值使用。
同样的，如果是整数类型转double类型，也不会发生数据截断，可以直接赋值使用。

#### 浮点型转整型

如果是浮点类型转int类型，会发生数据截断，需要强制转换。

float转int，float的取值范围是-3.4E38 ~ 3.4E38，int的取值范围是-2147483648 ~ 2147483647。
long的取值范围是-9223372036854775808 ~ 9223372036854775807。
float的取值范围比int和long的取值范围都要大，所以float转int和long都会发生数据截断。

同样的double比float的取值范围要大，所以double转int和long也都必然会发生数据截断。

如果实在需要转换，也可以用强制转换。

```java
float f=1.1f;
        int i=(int)f;
```

但是这样会丢失小数点后面的精度。

# 字符串

字符串是一种特殊的数据类型，它是一个字符序列，可以用来表示一串字符。他是一个类，但是他的底层是一个char数组。

## 字符串的定义

符串的定义有两种方式，一种是直接赋值，一种是使用构造方法。

java如果是直接使用双引号包裹起来的字符串，那么就会直接在字符串常量池中创建一个字符串对象。
如果是使用new关键字创建的字符串，那么就会在堆内存中创建一个字符串对象。

### 直接赋值

直接赋值的方式，就是直接使用双引号包裹起来的字符串，例如

```java
String str="hello";
```



